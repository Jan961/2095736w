import pynndescent
from hdimvis.algorithms.BaseAlgorithm import BaseAlgorithm
from hdimvis.algorithms.spring_force_algos.Node import Node
from hdimvis.algorithms.spring_force_algos.utils import jiggle, get_size, mean
from ...data_fetchers.Dataset import Dataset
from itertools import combinations
from typing import Tuple, List, Dict, FrozenSet
from abc import abstractmethod
import numpy as np
import math

# code adapted and modified from 2019 Project by Iain Cattermole

class SpringForceBase(BaseAlgorithm):

    available_metrics = ['Stress', 'Average speed']

    def __init__(self, dataset: Dataset | None,
                 nodes: List[Node] = None,
                 enable_cache: bool = True,
                 use_knnd: bool = False, knnd_parameters: Dict = None,  # k-nn descent algorithm parameters
                 neighbour_set_size: int = 5,
                 sample_set_size: int = 10,
                 spring_constant: float = 0.1,
                 sc_scaling_factor: float = None,
                 integrate_sum : bool = True, # consider the sum of all forces on a node at integration step
                 damping_constant: float = 0,
                 **kwargs) -> None:

        # the base class extracts data from the Dataset object
        super().__init__(dataset, **kwargs)

        assert neighbour_set_size > 0 or sample_set_size > 0, "Sample set and Neighbour set cannot be both zero"

        self.nodes: List[Node] = nodes if nodes is not None else self.build_nodes()
        self.neighbour_set_size: int = neighbour_set_size
        self.sample_set_size:    int = sample_set_size
        self._average_speeds: List[float] = list()
        self.enable_cache: bool = enable_cache
        self.sc_scaling_factor: float = sc_scaling_factor if sc_scaling_factor \
                                        else 0.5/(self.sample_set_size + self.neighbour_set_size)
        print(f" scaling factor: {self.sc_scaling_factor}")
        self.spring_constant = spring_constant
        self.damping_constant = damping_constant
        self.integrate_sum = integrate_sum
        self.knnd_parameters = knnd_parameters
        self.use_knnd = use_knnd
        if self.use_knnd:
            if self.data is not None:
                self.knnd_index = self.create_knnd_index()
            else:
                self.knnd_index = None

        if enable_cache:
            self.distances: Dict[FrozenSet[Node], float] = dict()
        else:
            # Change the distance function
            self.hd_distance = self.hd_distance_no_cache

    @abstractmethod
    def one_iteration(self, *args, **kwargs) -> None:
        """
        Perform one iteration of the algorithm
        """
        pass

    def build_nodes(self) -> List[Node] | None:
        """
        Construct a Node for each datapoint
        """
        if self.data is not None:
            # concatenate the datapoints with the initial positions for low-d mappings
            # for the apply_along_axis fn
            conc = np.concatenate((self.data, self.initial_layout), axis=1)
            return list(np.apply_along_axis(Node, axis=1, arr=conc))
        else:
            return None

    def get_positions(self) -> np.ndarray:
        return np.array([(n.x, n.y) for n in self.nodes])

    def set_positions(self, positions: np.ndarray) -> None:
        for pos, node in zip(positions, self.nodes):
            node.x, node.y = pos

    def get_average_speed(self) -> float:
        """ Return the 5-running mean of the average node speeds """
        return mean(self._average_speeds[-5:]) if len(self._average_speeds) > 0 else np.inf

    def hd_distance_no_cache(self, source: Node, target: Node, cache: bool = False) -> float:
        """ Distance function to use when self.disable_cache = True """
        return self.distance_fn(target.datapoint - source.datapoint)

    def hd_distance(self, source: Node, target: Node, cache: bool = False) -> float:
        """
        Returns the high dimensional distance between two nodes at source and target
        index using self.distance_fn
        """
        pair = frozenset({source, target})
        if pair in self.distances:
            return self.distances[pair]
        distance = self.distance_fn(source.datapoint - target.datapoint)
        if cache:
            self.distances[pair] = distance
        return distance

    def create_knnd_index(self):
        print("The algorithm will use a k-nearest neighbours graph generated by the k-NN Descent algorithm")
        if self.knnd_parameters is not None:
            return pynndescent.NNDescent(self.data, n_neighbors=self.neighbour_set_size + 1,
                                                    **self.knnd_parameters)  # knnd index shows the datapoint itself as
            # the 1st nn - hence neighbour_set_size + 1
        else:
            return pynndescent.NNDescent(self.data, n_neighbors=self.neighbour_set_size + 1)


    def _low_d_distances_xy(self, source: Node, target: Node) -> Tuple[float, float]:
        """
        Calculate the current 2d layout distance between two nodes.
        Apply a small non zero random value to remove values of zero
        """
        x = target.x - source.x
        y = target.y - source.y
        # x and y must be non zero
        x = x if x else 1e-12
        y = y if y else 1e-12
        return x, y


    def _calculate_force(self, source: Node, target: Node,
                         cache_distance: bool = False) -> Tuple[float, float]:
        """
        Calculate the spring force to apply between two nodes i and j
        """

        dist_x, dist_y = self._low_d_distances_xy(source, target) # x,y distance vector from source to target
        ld_dist = math.hypot(dist_x, dist_y)
        hd_dist = self.hd_distance(source, target, cache=cache_distance)
        # if k%500 == 0:
        # print(f"ld dist: {ld_dist}")
        # print(f"hd dist: {hd_dist}")
        first_term = self.spring_constant * ( ld_dist - hd_dist)

        if self.damping_constant != 0:
            #calculate "source" and "target" speeds in the direction of the distance between the two nodes
            direction_unit_vector = np.array([dist_x, dist_y])/(np.sqrt(sum([dist_x**2, dist_y**2])))
            speed_source = np.dot(direction_unit_vector, np.array([source.old_ux, source.old_uy]))
            speed_target = np.dot(-direction_unit_vector, np.array([source.old_ux, source.old_uy]))

            # zero negative speeds
            speed_source = 0 if speed_source < 0 else speed_source
            speed_target = 0 if speed_target < 0 else speed_target

             # damping linearly proportional to the sum of last speed values in the direction of the distance vector
            second_term = self.damping_constant * (speed_source + speed_target)
        else:
            second_term = 0

        # force magnitude; data_size_factor was included in the 2019 code but not in the original paper,
        # here it is set to 1 by default
        force_mag = (first_term - second_term) * self.sc_scaling_factor
        f_x = (dist_x/ld_dist) * force_mag
        f_y = (dist_y/ld_dist) * force_mag

        # print(f_x, f_y)
        # print(f"source : {source.x} , {source.y}")
        # print(f"target : {target.x} , {target.y}")

        return f_x, f_y


    def _set_position_update(self, source: Node, target: Node,
                             cache_distance: bool = False) -> None:
        """
        Calculate the force between two nodes and increment the position update
        the integration timestep for force and mass of the "particle" are assumed to be 1,
        hence acceleration = velocity = position update

        We simply add all the forces on top of each other as we go
        """
        f_x, f_y = self._calculate_force(source, target,
                                       cache_distance=cache_distance)

        source.increment_position_update(f_x, f_y)
        target.increment_position_update(-f_x, -f_y)


    def _apply_position_update(self) -> None:
        """
        Apply the current velocity of each node to its position
        and reset velocity
        """
        total: float = 0.0
        for node in self.nodes:
            total += math.hypot(node.ux, node.uy)
            node.apply_position_update()
            # print(f" node: {node.x}, {node.y} ")
        total /= len(self.nodes)
        self._average_speeds.append(total)
