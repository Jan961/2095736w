from hdimvis.algorithms.spring_force_algos.SpringForceBase import SpringForceBase
from hdimvis.algorithms.spring_force_algos.Node import Node
from ..utils import random_sample_set
from ....distance_measures.euclidian_and_manhattan import euclidean
from ....data_fetchers.Dataset import Dataset
from typing import Callable, List, Dict
import numpy as np
import pynndescent


class Chalmers96(SpringForceBase):
    """
    An implementation of Chalmers' 1996 Neighbour and Sampling algorithm.
    Using random sampling to find the closest neighbours from the data set.

    """

    name = 'Chalmers\' 1996'

    def __init__(self, neighbour_set_size: int = 5, sample_set_size: int = 10, use_knnd: bool = False,
                 knnd_parameters: Dict = None, **kwargs):

        # the base class extracts data from the Dataset object
        super().__init__( **kwargs)

        assert neighbour_set_size > 0 or sample_set_size > 0, "Sample set and Neighbour set cannot be both zero"

        self.neighbour_set_size: int = neighbour_set_size
        self.sample_set_size:    int = sample_set_size
        self.neighbours: Dict[int, List[int]] = dict() # dictionary used when no knnd index is supplied
        self.data_size_factor: float = 0.5 / (neighbour_set_size + sample_set_size)
        self.knnd_parameters = knnd_parameters
        self.use_knnd = use_knnd
        if self.use_knnd:
            if self.knnd_parameters is not None:
                self.knnd_index = pynndescent.NNDescent(self.data, n_neighbors=self.neighbour_set_size + 1,
                                                        **self.knnd_parameters) #knnd index shows the datapoint itself as
                                                                                # the 1st nn
            else:
                self.knnd_index = pynndescent.NNDescent(self.data, n_neighbors=self.neighbour_set_size + 1)
            print("The algorithm will use a k-nearest neighbours graph generated by the k-NN Descent algorithm")

    def get_name(self):
        return self.name


    def one_iteration(self, alpha: float=1) -> None:
        """
        Perform one iteration of the spring layout
        """
        assert self.data is not None or self.nodes is not None, "must provide dataset or nodes"

        n = len(self.nodes)
        for i in range(n):
            if self.sample_set_size:
                sample_set = self._get_sample_set(i)
                for j in sample_set:
                    self._set_velocity(self.nodes[i], self.nodes[j], alpha)

            if self.neighbour_set_size:
                neighbour_set = self._get_neighbours(i)
                for j in neighbour_set:
                    self._set_velocity(self.nodes[i], self.nodes[j], alpha, cache_distance=True)

            if not self.use_knnd and self.neighbour_set_size and self.neighbour_set_size:
                self._update_neighbours(i, samples=sample_set)
        self._apply_velocities()

    def _get_neighbours(self, index: int) -> List[int]:
        """
        Get the list of neighbour indices for a given node index sorted by distance.
        If no neighbours exist yet then they are randomly sampled.
        """
        if self.use_knnd:
            return self.knnd_index.neighbor_graph[0][index][1:].tolist()

        if index not in self.neighbours:
            random_sample = random_sample_set(self.neighbour_set_size, len(self.nodes), {index})
            random_sample.sort(
                key=lambda j: self.distance(self.nodes[index], self.nodes[j])
            )
            self.neighbours[index] = random_sample
        return self.neighbours[index]

    def _get_sample_set(self, i: int) -> List[int]:
        """
        Get a valid sample set for a node index by randomly sampling, excluding
        current node and neighbours of the node.
        """
        exclude = {i}.union(set(self._get_neighbours(i)))
        return list(random_sample_set(self.sample_set_size, len(self.nodes), exclude))

    def _update_neighbours(self, i: int, samples: List[int]) -> None:
        """
        Update the neighbour set for a given index from a sample set.
        Sample nodes are added to the neighbour set in sorted order if
        they are closer than the furthest current neighbour.
        """
        source = self.nodes[i]
        neighbours = self._get_neighbours(i)
        furthest_neighbour = self.distance(source, self.nodes[neighbours[-1]])
        for s in samples:
            sample_distance = self.distance(source, self.nodes[s])
            if sample_distance < furthest_neighbour:
                n = self.neighbour_set_size - 2
                neighbour_distance = self.distance(source, self.nodes[neighbours[n]])
                while sample_distance < neighbour_distance:
                    n -= 1
                    if n < 0:
                        break
                    neighbour_distance = self.distance(source, self.nodes[neighbours[n]])
                neighbours.insert(n + 1, s)
                distance_key = frozenset({source, self.nodes[neighbours[-1]]})
                if self.enable_cache and distance_key in self.distances:
                    del self.distances[distance_key]  # Remove distance from cache to save memory
                del neighbours[-1]
